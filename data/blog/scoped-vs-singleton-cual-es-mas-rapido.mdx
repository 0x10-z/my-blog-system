---
title: "Scoped vs Singleton: Â¿cuÃ¡l es mÃ¡s rÃ¡pido en .NET?"
date: "2025-06-20"
tags: [".NET", "WebAPI", "DI", "Performance", "Singleton", "Scoped"]
draft: false
authors: ['default']
summary: "Comparamos el rendimiento de servicios Singleton y Scoped en WebAPI usando BenchmarkDotNet. Â¿CuÃ¡l es mejor segÃºn el caso?"
images: ["/static/images/uploads/scoped-vs-singleton-cual-es-mas-rapido/1.webp"]
---

# ðŸ§ª Scoped vs Singleton: Â¿cuÃ¡l es mÃ¡s rÃ¡pido (y mÃ¡s seguro) en una Web API .NET?

En una aplicaciÃ³n Web API en .NET, cada vez que se recibe una peticiÃ³n HTTP, se inicia un nuevo flujo de ejecuciÃ³n: desde el controlador hasta los servicios de negocio, los repositorios y mÃ¡s allÃ¡. Y aquÃ­ es donde surge una decisiÃ³n clave de arquitectura:

> Â¿DeberÃ­amos registrar nuestros servicios como `Scoped` (una instancia por peticiÃ³n) o como `Singleton` (una sola instancia para toda la vida de la aplicaciÃ³n)?

Hay quienes defienden usar `Singleton` porque "evita la creaciÃ³n repetida" y "mejora el rendimiento". Otros recomiendan `Scoped` porque es mÃ¡s seguro y compatible con `DbContext`, entre otros argumentos.

En este post analizamos **los pros y contras de ambos enfoques**, y mostramos **pruebas de rendimiento reales** con [`BenchmarkDotNet`](https://benchmarkdotnet.org/). VerÃ¡s cÃ³mo el rendimiento puede cambiar drÃ¡sticamente segÃºn el tipo de trabajo que haga tu servicio â€” desde cÃ¡lculos triviales hasta cargas pesadas concurrentes.

Y sobre todo, sacamos conclusiones prÃ¡cticas para tu Web API: si tienes servicios que acceden a bases de datos, escriben registros, procesan datos concurrentemente... este anÃ¡lisis es para ti.

---

## âš—ï¸ Escenarios probados

Creamos cuatro servicios distintos, combinando dos dimensiones:

- **Singleton** vs **Scoped**
- LÃ³gica **ligera** vs lÃ³gica **pesada** (Fibonacci con `BigInteger`)

Cada servicio fue invocado en paralelo desde 8 hilos. Los resultados fueron medidos sin debugger y con `InvocationCount = 160`.

---

## ðŸ§  Caso 1: Servicio ligero

```csharp
public int DoWork() => 42;
````

| MÃ©todo           | Tiempo medio | Memoria |
| ---------------- | ------------ | ------- |
| âœ… SingletonLight | 5.12 Âµs      | 2.28 KB |
| ScopedLight      | 6.56 Âµs      | 5.04 KB |

**Â¿QuÃ© aprendemos?**

* El `Singleton` es ligeramente mÃ¡s rÃ¡pido porque no hay que instanciar nada.
* Esto es ideal para servicios sin estado, sin dependencias externas ni trabajo pesado.
* Sin embargo, si tu `LightService` termina dependiendo de un logger contextual, `DbContext`, o un token de usuario, probablemente dejarÃ¡ de poder ser `Singleton`.

---

## ðŸ”¥ Caso 2: Servicio pesado (Fibonacci)

```csharp
public int DoWork()
{
    BigInteger a = 0, b = 1;
    for (int i = 2; i <= 100; i++) (a, b) = (b, a + b);
    return b.ToString().Length;
}
```

| MÃ©todo         | Tiempo medio | Memoria  |
| -------------- | ------------ | -------- |
| SingletonHeavy | âŒ 64.08 Âµs   | 17.98 KB |
| âœ… ScopedHeavy  | 22.50 Âµs     | 20.67 KB |

**Â¿QuÃ© pasa aquÃ­?**

* El `Singleton` necesita proteger el acceso con un `lock`, lo cual **serializa el trabajo**. Solo un hilo trabaja a la vez.
* El `Scoped` crea una instancia por hilo â†’ **mÃ¡ximo paralelismo**.
* Aunque asigna mÃ¡s memoria, el coste se amortiza con creces cuando el trabajo interno es costoso.

---

## ðŸ§© Â¿QuÃ© pasa en una Web API real?

Imagina un servicio que interactÃºa con una base de datos:

```csharp
public class OrderService
{
    private readonly AppDbContext _dbContext;

    public void ConfirmOrder(int orderId)
    {
        var order = _dbContext.Orders.Find(orderId);
        order.Status = "Confirmed";
        _dbContext.SaveChanges();
    }
}
```

### âœ… Este servicio debe ser `Scoped`.

* `DbContext` es `Scoped`. Si lo inyectas en un `Singleton`, obtendrÃ¡s un error como:

```bash
Cannot consume scoped service 'MyDbContext' from singleton
```

* Incluso si haces un `CreateScope()` manual dentro del `Singleton`, estarÃ¡s **gestionando el ciclo de vida a mano**, y podrÃ­as:

  * Olvidar el `Dispose()`, causando fugas de memoria.
  * Generar `deadlocks` si combinas `lock` + creaciÃ³n de scopes.
  * Ocultar dependencias no evidentes, dificultando tests y mantenimiento.

---

## âš™ï¸ Â¿Y en un `BackgroundService`?

En `BackgroundService`, no hay una peticiÃ³n HTTP que cree el `Scope` automÃ¡ticamente. Si necesitas acceder a un servicio `Scoped`, **debes crear un `Scope` manualmente**:

```csharp
public class MyBackgroundWorker : BackgroundService
{
    private readonly IServiceProvider _provider;

    public MyBackgroundWorker(IServiceProvider provider)
    {
        _provider = provider;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            using var scope = _provider.CreateScope();
            var service = scope.ServiceProvider.GetRequiredService<IOrderService>();
            await service.DoWorkAsync();
        }
    }
}
```

ðŸ” En este caso estÃ¡ justificado el uso de `CreateScope()`, **porque tÃº gestionas el ciclo de vida del trabajo manualmente**.

---

## ðŸ§  Â¿QuÃ© implica usar un Singleton *thread-safe*?

Usar `Singleton` no es gratis. Aunque parece cÃ³modo ("se instancia una vez y se usa siempre"), tiene implicaciones serias si tu servicio:

* **Mantiene estado interno mutable** (como contadores, listas, diccionarios, etc.)
* Es accedido **desde mÃºltiples hilos** a la vez (lo que ocurre en casi cualquier Web API en producciÃ³n)

### âŒ Si no es thread-safe: tienes un problema

Cuando mÃºltiples hilos acceden y modifican el estado del singleton sin sincronizaciÃ³n:

* Puedes tener **condiciones de carrera**.
* El estado del objeto puede quedar **corrupto**.
* Puedes tener errores **intermitentes**, difÃ­ciles de reproducir y muy costosos de depurar.

```csharp
public class UnsafeCounterService
{
    private int _count = 0;

    public int Increment()
    {
        return _count++; // âŒ No es atÃ³mico ni thread-safe:
                         // Si dos hilos acceden al mismo tiempo, ambos pueden ejecutar estos pasos en paralelo:
                         //   1. Leer _count (por ejemplo, 0).
                         //   2. Calcular newValue = _count + 1 â†’ 1.
                         //   3. Asignar _count = newValue â†’ ambos asignan 1.
                         // Resultado: se pierde un incremento, y ambos hilos devuelven el mismo valor.
    }
}

```

### âœ… SoluciÃ³n 1: Hazlo inmutable

Un `Singleton` es seguro por diseÃ±o **si es inmutable**, es decir:

* No tiene campos que cambien de valor despuÃ©s del constructor.
* No guarda estado interno de ninguna forma.
* Solo opera sobre los datos que recibe por parÃ¡metro.

```csharp
public class TaxCalculator // âœ… Inmutable
{
    private readonly decimal _vat;

    public TaxCalculator(decimal vat)
    {
        _vat = vat;
    }

    public decimal Apply(decimal amount) => amount * _vat;
}
```

### âœ… SoluciÃ³n 2: Hazlo seguro mediante sincronizaciÃ³n

Si necesitas que el singleton tenga estado, debes proteger el acceso concurrente con:

* `lock` (sencillo pero puede bloquear)
* `Interlocked` (para operaciones atÃ³micas simples)
* `ConcurrentDictionary`, `ConcurrentQueue`, etc.

```csharp
public class SafeCounterService
{
    private int _count = 0;

    public int Increment()
    {
        return Interlocked.Increment(ref _count); // âœ… AtÃ³mico y rÃ¡pido
    }
}
```

> â— Pero cuidado: **el simple uso de `lock` no te salva si haces muchas operaciones costosas dentro**. Como vimos en los benchmarks, eso puede provocar cuellos de botella serios.

---

### ðŸ“Œ Checklist: Â¿puede ser Singleton?

Antes de registrar un servicio como Singleton, asegÃºrate de que cumple **todas** estas condiciones:

| Requisito                                                               |    |
| ----------------------------------------------------------------------- | -- |
| No guarda estado mutable interno                                        | âœ… |
| Es completamente inmutable tras su creaciÃ³n                             | âœ… |
| Todas sus operaciones son `thread-safe`                                 | âœ… |
| No depende de servicios `Scoped` como `DbContext`                       | âœ… |
| No utiliza `HttpContext`, claims, logging contextual u objetos efÃ­meros | âœ… |

---

## âœ… Conclusiones prÃ¡cticas

| Escenario                                   | Â¿QuÃ© usar?                   | Motivo                                              |
| ------------------------------------------- | ---------------------------- | --------------------------------------------------- |
| Servicio sin estado y lÃ³gica ligera         | Singleton                    | Reutilizable, rÃ¡pido y sin costes de creaciÃ³n       |
| Servicio ligero pero con dependencias       | Scoped                       | Encaja mejor con logging, contexto de usuario, etc. |
| Acceso a `DbContext`                        | Scoped                       | `DbContext` es `Scoped` por diseÃ±o                  |
| Alta concurrencia con lÃ³gica costosa        | Scoped                       | Permite paralelismo real sin cuellos de botella     |
| Servicio `Singleton` que usa `lock`         | Evitar si es muy concurrido  | Penaliza el rendimiento al bloquear mÃºltiples hilos |
| `BackgroundService` con dependencias scoped | Scoped + `CreateScope()`     | Justificado en este patrÃ³n de ejecuciÃ³n manual      |

---

## ðŸ’¡ Reglas de oro

> Usa `Scoped` por defecto en Web API.
> Usa `Singleton` **solo si**:
>
> * No tiene estado mutable.
> * Es thread-safe sin necesidad de `lock`.
> * No depende de servicios `Scoped`.
> * Su uso estÃ¡ limitado y claramente controlado.

---

Â¿Has tenido que usar `CreateScope()` en producciÃ³n? Â¿Te has topado con errores extraÃ±os por mezclar ciclos de vida? Comparte tu experiencia abajo ðŸ‘‡
